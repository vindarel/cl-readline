<!doctype html>
<html lang="en">
  <!--
  Documentation for cl-readline - bindings to GNU Readline library.
  
  Copyright (c) 2014 Mark Karpov
  
  Permission is granted to copy, distribute and/or modify this document
  under the terms of the GNU Free Documentation License, Version 1.3 or any
  later version published by the Free Software Foundation; with no Invariant
  Sections, no Front-Cover Texts, and no Back-Cover Texts.  A copy of the
  license is included in the section entitled "GNU Free Documentation
  License".  -->
  <head>
    <meta charset="utf-8">
    <meta name="description"    content="cl-readline documentation">
    <meta name="author"         content="Mark Karpov">
    <meta name="dcterms.rights" content="(c) 2014 Mark Karpov">
    <meta name="keywords"       content="GNU Readline, Common Lisp">
    <title>cl-readline</title>
    <link href="ascetic.css" rel="stylesheet" type="text/css">
  </head>
  <body>
    <h1>cl-readline</h1>
    <h2 id="0">Table of Contents</h2>
    <ul class="no-bullet">
      <li><a href="#1">1 Overview of cl-readline</a></li>
      <li><a href="#2">2 Basic Functionality</a>
        <ul class="no-bullet">
          <li><a href="#2.1">2.1 Symbol Macros</a></li>
          <li><a href="#2.2">2.2 Functions</a></li>
      </ul></li>
      <li><a href="#3">3 Hooks and Custom Functions</a>
        <ul class="no-bullet">
          <li><a href="#3.1">3.1 Symbol Macros</a></li>
          <li><a href="#3.2">3.2 Functions</a></li>
      </ul></li>
      <li><a href="#4">4 Work with Keymaps</a>
        <ul class="no-bullet">
          <li><a href="#4.1">4.1 Symbol Macros</a></li>
          <li><a href="#4.2">4.2 Functions</a></li>
      </ul></li>
      <li><a href="#5">5 Binding Keys</a></li>
      <li><a href="#6">6 Associating Function Names and Bindings</a></li>
      <li><a href="#7">7 Allowing Undoing</a></li>
      <li><a href="#8">8 Redisplay</a></li>
      <li><a href="#9">9 Modifying Text</a></li>
      <li><a href="#10">10 Character Input</a></li>
      <li><a href="#11">11 Terminal Management</a></li>
      <li><a href="#12">12 Utility Functions</a></li>
      <li><a href="#13">13 Miscellaneous Functions</a></li>
      <li><a href="#14">14 Signal Handling</a>
        <ul class="no-bullet">
          <li><a href="#14.1">14.1 Symbol Macros</a></li>
          <li><a href="#14.2">14.2 Functions</a></li>
      </ul></li>
    </ul>
    <h2 id="1">1 Overview of cl-readline</h2>
    <p>cl-readline is bindings to GNU Readline library.</p>
    <p>The Readline library provides a set of functions for use by
      applications that allow users to edit command lines as they are typed
      in. Both Emacs and vi editing modes are available. The Readline
      library includes additional functions to maintain a list of
      previously-entered command lines, to recall and perhaps reedit those
      lines, and perform csh-like history expansion on previous
      commands.</p>
    <p>This bindings provide Lispy interface to GNU Readline somewhat
      reducing its hair. Some minor features are omitted, they may be added
      by request. Open an issue if you have any propositions.</p>
    <p>Manual Copyright &copy; 2015 Mark Karpov.</p>
    <p>cl-readline Copyright &copy; 2015 Mark Karpov.</p>
    <p>All contents here is copyright by the developer and is released under
      the <a href="http://www.gnu.org/copyleft/fdl.html"> GNU Free
      Documentation License</a>.</p>
    <p>cl-readline is licensed
      under <a href="http://www.gnu.org/copyleft/gpl.html">GNU General
      Public License v.3</a>; it's free software.</p>
    <p>[<a href="#0">contents</a>]</p>
    <h2 id="2">2 Basic Functionality</h2>
    <p>This sections describes most basic functions and symbol-macros that
      represent underlying C variables. For every symbol macro we give data
      type it evaluates to. If name of a symbol macro is enclosed in plus
      signs (for example, <code>+prompt+</code>), it means that you should
      not (and, in fact, cannot) modify its value. Other symbol macros are
      setfable and you can set their values with <code>setf</code>
      macro.</p>
    <p>[<a href="#0">contents</a>]</p>
    <h3 id="2.1">2.1 Symbol Macros</h3>
    <p><u>Symbol macro</u> <code><b>*line-buffer*</b></code> &ndash;
      string<br> This is the line gathered so far. You are welcome to modify
      the contents of the line, but remember about undoing. The
      function <code>extend-line-buffer</code> is available to increase the
      memory allocated to <code>*line-buffer*</code>.</p>
    <p><u>Symbol macro</u> <code><b>*point*</b></code> &ndash;
      integer<br>The offset of the current cursor position
      in <code>*line-buffer*</code> (the point).</p>
    <p><u>Symbol macro</u> <code><b>*end*</b></code> &ndash; integer<br>The
      number of characters present
      in <code>*line-buffer*</code>. When <code>*point*</code> is at the end
      of the line, <code>*point*</code> and <code>*end*</code> are
      equal.</p>
    <p><u>Symbol macro</u> <code><b>*mark*</b></code> &ndash; integer<br>The
      mark (saved position) in the current line. If set, the mark and point
      define a region.</p>
    <p><u>Symbol macro</u> <code><b>*done</b></code> &ndash;
      Boolean<br>Setting this to a non-<code>nil</code> value causes
      Readline to return the current line immediately.</p>
    <p><u>Symbol macro</u> <code><b>+prompt+</b></code> &ndash;
      string<br>The prompt Readline uses. This is set from the argument
      to <code>readline</code>, and should not be assigned to
      directly. The <code>set-prompt</code> function may be used to modify
      the prompt string after calling
      <code>readline</code>.</p>
    <p><u>Symbol macro</u> <code><b>*display-prompt*</b></code> &ndash;
      string<br>The string displayed as the prompt. This is usually
      identical to <code>+prompt+</code>, but may be changed temporarily by
      functions that use the prompt string as a message area, such as
      incremental search.</p>
    <p><u>Symbol macro</u> <code><b>+library-version+</b></code> &ndash;
      string<br>The version number of this revision of the library.</p>
    <p><u>Symbol macro</u> <code><b>+readline-version+</b></code> &ndash;
      two integer values<br>Major and minor version numbers of Readline
      library.</p>
    <p><u>Symbol macro</u> <code><b>+gnu-readline-p+</b></code> &ndash;
      Boolean<br> Always evaluated to <code>t</code>, denoting that this is
      GNU readline rather than some emulation.</p>
    <p><u>Symbol macro</u> <code><b>*readline-name*</b></code> &ndash;
      string<br>This symbol-macro should be set to a unique name by each
      application using Readline. The value allows conditional parsing of
      the inputrc file.</p>
    <p><u>Symbol macro</u> <code><b>+readline-state+</b></code> &ndash; list
      of keywords<br>This symbol macro is evaluated to a list containing
      keywords that denote state of Readline. The following flags are used:
      <ul>
        <li><code>:initializing</code> &ndash; initializing;</li>
        <li><code>:initialized</code> &ndash; initialization done;</li>
        <li><code>:termprepped</code> &ndash; terminal is prepped;</li>
        <li><code>:readcmd</code> &ndash; reading a command key;</li>
        <li><code>:metanext</code> &ndash; reading input after ESC;</li>
        <li><code>:dispatching</code> &ndash; dispatching to a command;</li>
        <li><code>:moreinput</code> &ndash; reading more input in a command
          function</li>
        <li><code>:isearch</code> &ndash; doing incremental search;</li>
        <li><code>:nsearch</code> &ndash; doing non-incremental search;</li>
        <li><code>:search</code> &ndash; doing a history search;</li>
        <li><code>:numericarg</code> &ndash; reading numeric argument;</li>
        <li><code>:macroinput</code> &ndash; getting input from a
          macro;</li>
        <li><code>:macrodef</code> &ndash; defining keyboard macro;</li>
        <li><code>:overwrite</code> &ndash; overwrite mode;</li>
        <li><code>:completing</code> &ndash; doing completion;</li>
        <li><code>:sighandler</code> &ndash; in readline sighandler;</li>
        <li><code>:undoing</code> &ndash; doing a undo;</li>
        <li><code>:inputpending</code> &ndash; <code>execute-next</code>
          called;</li>
        <li><code>:ttycsaved</code> &ndash; tty special chars saved;</li>
        <li><code>:callback</code> &ndash; using the callback
          interface;</li>
        <li><code>:vimotion</code> &ndash; reading vi motion argument;</li>
        <li><code>:multikey</code> &ndash; reading multiple-key
          command;</li>
        <li><code>:vicmdonce</code> &ndash; entered vi command at least
          once;</li>
        <li><code>:redisplaying</code> &ndash; undating terminal
          display;</li>
        <li><code>:done</code> &ndash; done; accepted line.</li>
      </ul>
    </p>
    <p><u>Symbol macro</u> <code><b>+editing-mode+</b></code> &ndash;
      keyword<br>Evaluated to keyword denoting actual editing
      mode: <code>:emacs</code> or <code>:vi</code>.</p>
    <p>[<a href="#0">contents</a>]</p>
    <h3 id="2.2">2.2 Functions</h3>
    <p><u>Function</u> <code><b>readline</b> &amp;key prompt
        already-prompted num-chars erase-empty-line add-history</code></p>
    <p>Get a line from user with editing. If <code>prompt</code> supplied
      (and it's a string designator), it will be printed before reading of
      input. Non-<code>nil</code> value of <code>already-prompted</code>
      will tell Readline that the application has printed prompt
      already. However, <code>prompt</code> must be supplied in this case
      too, so redisplay functions can update the display properly. If
      <code>num-chars</code> argument is a positive number, Readline will
      return after accepting that many
      characters. If <code>erase-empty-line</code> is not <code>nil</code>,
      <code>readline</code> will completely erase the current line,
      including any prompt, any time a newline is typed as the only
      character on an otherwise-empty line. The cursor is moved to the
      beginning of the newly-blank line. If <code>add-history</code>
      supplied and its value is not <code>nil</code>, user's input will be
      added to history. However, blank lines don't get into history
      anyway. Return value on success is the actual string
      and <code>nil</code> on failure.</p>
    <p><u>Function</u> <code><b>add-defun</b> name function &optional
        key</code></p>
    <p>Add <code>name</code> to the list of named
      functions. Make <code>function</code> be the function that gets
      called. If <code>key</code> is not <code>nil</code> and it's a
      character, then bind it to function
      using <code>bind-key</code>. <code>function</code> must be able to
      take two arguments: integer representing its argument and character
      representing key that has invoked it.</p>
    <p>[<a href="#0">contents</a>]</p>
    
  </body>
</html>
